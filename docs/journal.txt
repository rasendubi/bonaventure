Bonaventure Journal

2018-12-27 (Thursday)
x   Three related issues:
    x   Interface between the scenario and the engine
    x   Event guards and hooks
        x   I.e, actions taken before and after an event occurs:
            x   Guard: Kill the player if they touch the sword with dirty hands.
                x   Or, simply don't let them take it.
            x   Hook: Soil the note if they take it with dirty hands.
    x   Custom visuals
        x   How you look depends on whether your hands are dirty or not.
x   Scenario/engine Interface
    x   Logic required by the scenario can be supported by the engine in one
        of two ways:
        x   By simply being part of how the world works, e.g.,
            the engine naturally supports getting and dropping things, and
            moving from location to location.
        x   By providing hooks and other mechanisms for extending the logic.
            x   Ultimately, this should be driven by data rather than Rust
                code, so that the scenario can be entirely saved to a
                scenario file.
    x   At present, the game includes the following logic that is "out of
        place":
        x   HasWater, DirtyHands, and Dirty flags.
            x   These are scenario-specific, but are hard-coded into the
                Flag type.
        x   visual::player() method
            x   Description of the player changes based on DirtyHands flag.
        x   "wash", "wash hands" commands
            x   These are scenario-specific, but implemented in the
                player control system.
    x   How to handle scenario flags?
        x   Custom Flags
            x   Add a flag Flag(&'static str)
                x   The user can add as many of these as needed, using
                    a constant string as the associated data.
            x   Add a flag EntFlag(ID, &'static str)
                x   Similar, for flags associated with a given entity.
        x   Note: For a pure-Rust implementation, Flag(&'static str) makes
            more sense, since you'll want to use a const &str.  If scenarios
            can be read from a scenario file, it will need to be String.
    x   How to handle custom descriptions?
        x   Need a description hook of some kind.  It should be used whenever
            the entity is described.  And there are probably flavors.
        x   What are the flavors?
            x   Extend visual
            x   Replace visual
            x   Do nothing
    x   How to handle command-specific code?
        x   Custom command handlers
            x   E.g., "wash hands" can work even if there is no thing with
                noun "hands".
        x   Entity Event guards and hooks
            x   An Entity Event is an event that involves the player and an
                entity, e.g.,
                x   Get<thisObject>
                x   Enter<thisRoom>
                x   Note: call them Events instead of Actions to distinguish
                    them from rule/command actions.
            x   An event guard indicates whether or not the given event should
                be allowed or denied, e.g., Get(sword). Can return Allow or
                Deny.
                x   Can take other actions as well: If you try to take the
                    sword with dirty hands, it kills you.
                x   Returns Allow/Deny rather than OK/Err, because Deny is not
                    an error: it just means that the guard has done everything
                    that needs to be done, and the remainder of the event
                    need not occur.
            x   An event hook takes effect *after* the event occurs, i.e.,
                after the note is taken.  It is like a rule that is triggered
                by the event.  It might output a message and take various
                actions.
                x   If you take the note with dirty hands, the note becomes
                    illegible.
                    x   This is better than a rule that fires every turn.
            x   How to represent event guards and hooks?
                x   Option A: As part of the ThingComponent.
                    x   ThingComponent has guard: HashMap<Event>
                        and hook: HashMap<Event>
                    x   When acting on a thing, the relevant engine code looks
                        for the guard and hook and uses them as appropriate.
                    x   Issue: both rooms and things can have guards and hooks,
                        just with different events.
                x   Option B: As distinct entities.
                    x   Each guard and hook is a distinct entity with a
                        GuardComponent or HookComponent
                    x   On Get(SWORD), the relevant engine code
                        looks through the entities for a Get(SWORD) guard/hook.
                    x   Issue: could have multiple guards/hooks for a given
                        entity and event.  That's probably not what we want.
                    x   Issue: have to search through all entities to find the
                        relevant guard/hook.
                x   Option C: As distinct entities, referenced by ID
                    x   I.e., the "sword" entity has the ID of the Get(sword)
                        guard entity.
                    x   Issue: Every software problem can be solved by adding
                        another level of indirection, but that doesn't make it
                        a good idea.
                x   Option D: As GuardComponent/HookComponent on the entity
                    itself.
                    x   Like A, but can be added to any kind of entity.
                    x   This kind of thing always involves an event on a
                        specific entity, so having the components on that
                        entity makes sense.
                x   Conclusion: Use Option D.
            x   Non-repeating Guards/Hooks
                x   Sometimes a Guard or Hook only applies for a short time,
                    e.g., the first time you pick up the note.
                x   Two ways to handle this:
                    x   Thing swapping, as we do with note.clean and note.dirty.
                        x   The thing that gets swapped in lacks the hook.
                    x   Custom flags
                        x   The hook sets a custom flag that prevents it from
                            firing again.
            x   Guard Definition
                x   A guard is a closure |world, id, event| -> GuardResult,
                    where GuardResult is an enum Allow, Deny
                    x   Or, Allow(Vec<Action>), Deny(Vec<Action>) if we want
                        to define it in a data-driven way.
            x   Hook Definition
                x   A hook is a closure |world, id, event| -> ()
                    x   Or, -> Vec<Action> for a data-driven solution
                x   A hook doesn't change the basic event; it just adds
                    additional behavior *after* the event occurs.
        x   How to implement Visual Hooks
            x   These need to be attached to ThingComponent and RoomComponent,
                since they have distinct visuals.
            x   The visual can be a sum type: Prose(String), Hook(closure).
                x   closure: |world, id| -> (): the closure is responsible
                    for printing the text using visual::<tbd>
                x   Note, the closure can also take actions, e.g., set flags.
                    x   Examining a note can set a flag allowing the player
                        to access a particular dictionary entry.
                x   For data driven, could return Vec<Action>
            x   Possibly define VisualComponent, with map of different kinds
                of visuals?
                x   Nah.  Seems unnecessary.
x   Best order to make these changes?
    x   Do the visual hook first, as it doesn't require affecting the command
        logic.
    x   Then, add event hooks, and replace the dirty note rule with one.
    x   Then, add event guard, and a sword that kills you if you touch it
        with dirty hands.
    x   Do the custom flag types last; that implementation doesn't make sense
        until the custom flags are all referenced in a single module.
    x   Then, consider making the hooks data driven.
    x   And then, scrub the resulting scenario code: try to make it
        easier for the scenario designer.

2018-12-26 (Wednesday)
x   LOTS of work done so far today.
    x   Completely refactored the entity data structures.
    x   Components are stored in component-specific hash maps; there is
        no longer any Entity struct.
    x   Every component has a *Component struct; these are in
        crate::entity submodules.
    x   It seems to be working, but I need to do lots of testing
        (and add test suites where appropriate).
x   Testing.
    x   Found bug in World::put_in.  Fixed.
x   Moved "connect()" and "oneway" from scenario.rs to world.rs as
    World::twoway() and World::oneway.
x   Looked at using termion in Bonaventure.
    x   Tricky.  I'd need to format!() the control strings into
        variables, and then build up my output myself.

2018-12-25 (Tuesday)
x   Getting back to basics.
x   "restart" or "undo" commands
    x   To restart the game means creating a new World struct.  But the
        World struct *is* the game struct; there's no way a method can
        mutate the World to create a new World.
        x   Implies that we need a game struct that owns the World, and that
            we pass the Game to the systems.  Then the player_control system
            can define an entirely new World.
        x   We probably also want a "Scene" object or function pointer,
            with which the game is configured, that's used to create the
            new world.
        x   For "restart" we don't need to preserve the player data or
            a state of the World (we can simply recreate the whole thing)
            but for "undo" we would need to.  That means that the World
            needs to support clone().
x   Implemented a Game struct and a "restart" command, but it isn't right yet.
    x   "restart" does indeed recreate the game.
    x   BUT, the player view is saved when the command ends; and it is no
        longer valid.
    x   We end up with the new World, but the old Player.  This is no good.
        x   Which, I suppose, is not surprising; this bug is inherent in the
            view scheme I'm using.
    x   However, I need to handle this.  What are my options?
        x   Option A: reset PlayerView
            x   On restart, set the read-write fields of the PlayerView
                to match the new world.  Then when they get written back,
                there's no problem.
            x   ISSUE: I can't change what the system's player variable
                points to, so I can't restore the PlayerView wholesale.
            x   I'd have to set the particular fields, which is fragile;
                later on I'll add one, and forget to reset it on restart.
                No good.
        x   Option B: Make/save PlayerView explicitly
            x   Each command acquires and saves PlayerView.  This is safer,
                but tedious; and I'm likely to forget a save() at some point.
        x   Option C: Special OK returns
            x   At present, OK returns ().  But I could make it an Enum
                for the different special cases, e.g., Restart, Undo.
    x   Option C appears to work pretty well.
x   Made World cloneable
    x   Just had to derive Clone for World and Entity.
x   Next:
    x   Figure out where Game struct should go.
    x   Undo
x   Undo
    x   At beginning of player_control::system(), clone the world.
    x   On Ok(Normal), push the clone onto the undo stack.
    x   On Ok(Undo), set the world to the state at the top of the stack.
    x   On Ok(Restart), clear the stack.
        x   The actual restart should be done on Ok(Restart), not in the
            cmd_restart routine.  In fact, "restart" => Ok(Restart).
x   Did all that.

2018-12-24 (Monday)
x   Command Processing
    x   Input parsing
        x   Commands beginning with "!" are debugging commands, and
            should be processed separately.
        x   The "." character separates individual commands on the
            command line.
            x   However entered, each command represents a game turn.
            x   Consequently, we need a command queue.
            x   However, some situations should clear the queue.
                x   Command errors.
        x   Other punctuation should be removed, e.g., commas.
        x   Finally, each command is broken on whitespace into a list of
            words.
    x   Command simplification
        x   Once a command has been discovered, it needs to be prepared
            for execution.
        x   Strip articles (a, an, the) as they do not affect the sense.
        x   Replace synonyms with canonical words, e.g., from "n" to
            "north", from "x" to "examine", from "take" to "get".
            x   Simplifies the pattern matcher.
            x   We need a mapping from synonyms to canonical words
            x   Probably necessary only for verbs; nouns and (eventually)
                adjectives are visible in the text, but verbs have to
                be guessed at.
            x   Probably want a "verbs" command to list the canonical
                verbs.
            x   The scenario needs to be able to add synonyms.
        x   Then, normal pattern matching can be used to execute the
            commands.
    x   Sentence forms
        x   Normal pattern matching can take us from command vectors
            to cmd_* functions for execution.  However, by studying
            the command forms, we can conceivably automate much of
            the error handling.
        x   [verb]
            x   E.g., "east", "west", "look", "help", "verbs".
            x   Execute the verb.
        x   [verb, noun:visible]
            x   "examine"
            x   Perform the verb on a thing that's visible in the
                room:
                x   In the player's inventory
                x   In the room's inventory
                x   Ultimately, in any open container in the room.
        x   [verb, noun:cantake]
            x   "get"
            x   Perform the verb on the noun that is visible and can
                be picked up.
            x   E.g., "get note".
        x   [verb, noun:held]
            x   "drop"
            x   Perform the verb on the noun.
        x   [verb, noun:usable]
            x   "read"
            x   The noun must be available for use.  As a rule,
                a noun is available for use if it is:
                x   visible
                x   If portable, then held.
            x   E.g., "read note".
x   Ideas:
    x   Maybe add a system that scans the list of things and categorizes them
        between game turns.
        x   Visible, Held, Takeable, Droppable, etc.
        x   Save them in lists owned by the PlayerComponent.
            x   visible, held, takeable, etc.
            x   THIS.  This is very cool, and will simplify the
                command processing a lot.
                x   Puts all of the logic in one place.
            x   Eventually, the same scheme can be used by NPCs.
        x   However, how does this work with special actions, e.g.,
            "wash hands"?
    x   Perhaps better:
        x   Absolutely compute which things are "visible" once.
        x   Then provide predicates for other conditions, e.g.,
            held, gettable, usable, portable, etc.
    x   This all seems to be part of the inventory system.
        x   Or, maybe call it the "stuff" system.
x   Defined input parsing and command simplification
    x   Defined Command struct; that's where the data goes.
    x   Defined article and punctation stripping.
    x   Defined synonym mapping
    x   Leaving multiple commands/command queue for later.
    x   DONE.
x   Added "readline" support using rustyline.  Very nice.
x   Fancy command patterns (e.g., matching against "noun:held"), etc.,
    should wait until I have the "stuff"/"inventory"/"environment"
    system implemented.
x   "Environment" system:
    x   Queries and summarizes the environment from the standpoint of
        an agent (i.e., the player or an NPC)
        x   What things are visible
        x   Aspects of those things: Held, Usable, Gettable
            x   Need ability to do magic things, i.e.,
                "It slips from your fingers" error when you try to
                pick up something slippery.
    x   Probably want to wait on this until I've got a better idea
        of what will be needed.
x   Gaps: Things text adventures do that I haven't implemented yet.
    x   Monsters
        x   Things that act on their own, and might frustrate you
    x   NPCs
        x   Characters that you can interact with, and might or might
            not act on their own.
        x   Text-oriented dialogs.
            x   Should affect the prompt.
    x   Doors (locked and otherwise)
    x   Containers (locked and otherwise)
    x   Windows
x   Wild ideas: how to make this a real game.
    x   Nobody needs a standard text adventure framework; that (very small)
        niche is covered.  Plus, I'm not a great I/F author.
    x   So what could I do?
    x   More of a combat-oriented, dungeon crawling thing, with puzzles.
        x   i.e., sort of a text-oriented Zelda
    x   Maybe with some character visuals: maps and things.
    x   Amazingly retro, yet not really like anything that's been done.
        x   Except maybe by MUDs
    x   A game with missions
x   So what would I want to see?
    x   Beautiful descriptions
    x   Interesting characters
    x   Worthwhile loot
    x   Replay-ability
        x   Some randomness
        x   Multiple playing styles
    x   Player has equipment
    x   Missions to go on.
    x   Vehicles, and places you can only go in them.
    x   Distinct places to go
        x   The player moves from "world" to "world".
        x   All we need to save is the player.
    x   Monsters to kill, so weapons, etc...but more like Hack than Angband.
    x   Could use termion, quite reasonably.
        x   Displays current status and location
        x   Could have mini-games that use keystrokes for movement,
            i.e., a mixture of rogue-like and text adventure.
        x   Could display maps
    x   Memory of things you've learned.
x   How should it start?
    x   With a tutorial.  You've got some equipment, some monsters,
        goal is to get to safety.
    x   Should help you along in the usual way.
    x   Collect weapons, fight some bad guys.
    x   Hack your way through the jungle.
    x   Use the password from the note once you manage to read it?
x   Mechanism: events
    x   Different actions trigger different events.  I.e., taking the
        note with dirty hands gets it dirty; taking the sword from the
        stone (the emotional support sword) makes the stone suddenly and
        softly vanish away.
    x   Perhaps user actions can "send events", which can trigger rules.
x   Architecture
    x   Game owns player and current scene
    x   Game knows about other worlds
    x   Only one world is active at a time.
    x   The player becomes an entity in the current scene.
        x   Copy in, copy out.
    x   Entities will clearly need to be dynamic.
    x   Hmmm.  Items, weapons, etc., are entities as well.  Need to
        be preserved across worlds (at least the ones carried by the user).
        x   How to manage this?
        x   Could keep persistent entities in a different list.
        x   Could simply copy the player and his belongings into a
            new vector, and use it as the base for the next world.
            x   Probably this.
        x   Use BTreeMap instead of Vec, so that we never need to
            defrag.
        x   Wrap it into an EntityMap, which keeps track of the next
            index.
        x   Alternatively, just use Vec; then on return to the home area
            begin by building a new vec with just the player and his things
            (equipment and inventory).

2018-12-23 (Sunday)
x   Text formatting plan
    x   Add conmark module
        x   Reference the textwrap crate.
        x   Add conmark::conwrap(), which uses textwrap to wrap to
            the console line length.
        x   Add conmark::confmt(), which responds to a dirt-simple
            markup.
            x   textwrap honors newlines, which is good.
            x   But the newlines in multi-line strings are usually
                not where we want line-breaks.
            x   conmark::confmt() processes a string like this:
                x   Trims beginning and end.
                x   Replaces newlines with spaces.
                x   Replaces "|" with newline.
                    x   Put newline at the *beginning* of a new line.
            x   Normally, then, a string will be flattened and wrapped,
                but specific strings can choose to have additional
                formatting.
    x   In console::, add output methods that use confmt and conwrap.
        x   And add macros that use format! on their argument, and
            call the confmt/conwrap output methods.
    x   Add visual:: module that uses these.
x   Things done:
    x   Added conmark::
    x   Added console:: methods
    x   Added visual:: system, and revised the app to use it.
    x   Added visual::prose()...para() mechanism for building up and
        outputting strings.

2018-12-22 (Saturday)
x   Lots of stuff to think about.
x   Room/Thing Hybrids
    x   Observations
        x   A vehicle is a thing:
        x It can be described as part of the content of a room.
        x It can be moved from room to room (by driving it).
    x   A vehicle is a room:
        x   The player can be inside it.
        x   It can be described as a location.
        x   It will have its own inventory.
    x   I can implement this a couple of ways
        x   Option A: As a single entity which has the components for a
            Thing and for a Room (and possibly for a Vehicle as well)
        x   Option B: As two entities with a special link between them.
    x   Option A seems simpler.
        x   But then, Rooms and Things need different prose, because
            a Vehicle would need both.
        x   Implies a ThingComponent and a RoomComponent.
            x   Neither would include the Inventory, as
                players, things, rooms, and NPCs can all have inventories.
x   Visual System
    x   In standard ECS, the systems are independent, and the main loop
        fires each in turn.
    x   This is useful; but that's mostly because everything's happening
        at once, e.g., the Visual System needs to render the results of
        the Physical system, etc.
    x   In Bonaventure, the basic time unit is the player turn, and
        visuals are triggered by the player's actions, e.g., you don't
        re-render the room if the player hasn't changed rooms, unless
        the player specifically looks at it.
    x   But that doesn't mean that we can't have a visual system that's
        responsible for displaying information about things, rooms,
        vehicles, etc, from the player's point of view.
    x   Instead of the single "system()" method, it would have a variety
        of methods for different kinds of description, and would be
        responsible for "rendering" a description as formatted text.
x   Scenery vs. Other Things
    x   At present, both scenery and movable things are in the room's
        inventory.
        x   In some ways would be more convenient to have two inventory
            lists one for scenery and one for non-scenery.
        x   But what if we then need three kinds of thing: do we add
            a third list?
    x   I think just like we need a visual system, we need an inventory
        system, for interacting with the things available to the player
        in his current environment.  It would provide methods for
        finding things by name, getting their details, finding lists of
        different kinds of things, and so forth.
x   Architectural Issues
    x   The World struct should provide methods for low-level manipulation
        and simple queries
        x   These form the basic mechanism layer, and will be used by
            the user's actions.  They are useful for updating multiple
            entities at once, when creating multiple views would be
            onerous.
        x   E.g.,
            x   Remove a thing from a location
            x   Put a thing in a location, and update the location's
                inventory
            x   Get a thing's location
            x   Get a view of an entity
            x   Get a view of the player
            x   Link two rooms in a direction.
            x   Bidirectional link two rooms in two directions
            x   Delete the link(s) between two rooms
    x   The code should be divided in two layers: the scenario and the
        engine.
        x   Ideally, any logic written in Rust should be in the engine.
        x   The scenario should be stuff that in principle could be loaded
            from a data file.
        x   That means that any predicates or actions defined by the
            scenario need to be definable as "byte code", not as closures.
        x   Also, the scenario can't add to the set of Flags; which means
            we need some generic Flags for scenario use.
x   Revised the debugging verbs.
    x   All debugging verbs begin with "!".
        x   At present this is done in the normal command parser; the
            verb simple begins with a "!" character.
        x   Might want to use a special parser for debugging commands,
            triggered by an initial "!".
            x   Would allow circumventing any grammar code.
            x   Would be easier to disable all debugging commands.
    x   Debugging commands that take an entity argument now accept
        tags as well as IDs.
    x   Added !examine, !look, and !go.
x   Rooms vs. Things vs. NPCs
    x   A room must have:
        x   A name
        x   A visual string
        x   Links
        x   An inventory
        x   A variable set
    x   A thing must have
        x   A noun, for use in the grammar
        x   A name for display
        x   A visual string
        x   A location
        x   A variable set
        x   Possibly, an inventory
    x   An entity that is both a room and a thing will need:
        x   Only one variable set
        x   Only one inventory.
        x   Only one set of Links
        x   A room name and visual string
        x   A thing name and visual string and noun.
    x   An NPC is a thing with behavior
x   Added PlayerInfo, RoomInfo, ThingInfo components based on the above
    analysis.
    x   The EntityBuilder syntax is now much nicer;
        x   The new player(), room(), and thing() methods unequivocally
            add those components in an unequivocal way.
        x   They also add necessary trimmings, i.e., inventory for both
            room and player.
x   RuleComponent is now RuleInfo.
    x   Added an action() EntityBuilder method.  The once() and always()
        methods add a rule with an empty actions vector; action() requires
        that the entity be a rule, and adds the action to the vector.
x   ProseComponent is now BookInfo.
    x   You can only add a book() to an entity if it's already a thing.
x   Removed obsolete components, e.g., name, loc, visual.
x   Replaced the VarSet type alias with a rule type, FlagSet.
    x   Vars are now Flags, because they really are.
