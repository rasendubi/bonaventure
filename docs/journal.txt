Bonaventure Journal

2018-12-24 (Monday)
x   Command Processing
    x   Input parsing
        x   Commands beginning with "!" are debugging commands, and
            should be processed separately.
        x   The "." character separates individual commands on the
            command line.
            x   However entered, each command represents a game turn.
            x   Consequently, we need a command queue.
            x   However, some situations should clear the queue.
                x   Command errors.
        x   Other punctuation should be removed, e.g., commas.
        x   Finally, each command is broken on whitespace into a list of
            words.
    x   Command simplification
        x   Once a command has been discovered, it needs to be prepared
            for execution.
        x   Strip articles (a, an, the) as they do not affect the sense.
        x   Replace synonyms with canonical words, e.g., from "n" to
            "north", from "x" to "examine", from "take" to "get".
            x   Simplifies the pattern matcher.
            x   We need a mapping from synonyms to canonical words
            x   Probably necessary only for verbs; nouns and (eventually)
                adjectives are visible in the text, but verbs have to
                be guessed at.
            x   Probably want a "verbs" command to list the canonical
                verbs.
            x   The scenario needs to be able to add synonyms.
        x   Then, normal pattern matching can be used to execute the
            commands.
    x   Sentence forms
        x   Normal pattern matching can take us from command vectors
            to cmd_* functions for execution.  However, by studying
            the command forms, we can conceivably automate much of
            the error handling.
        x   [verb]
            x   E.g., "east", "west", "look", "help", "verbs".
            x   Execute the verb.
        x   [verb, noun:visible]
            x   "examine"
            x   Perform the verb on a thing that's visible in the
                room:
                x   In the player's inventory
                x   In the room's inventory
                x   Ultimately, in any open container in the room.
        x   [verb, noun:cantake]
            x   "get"
            x   Perform the verb on the noun that is visible and can
                be picked up.
            x   E.g., "get note".
        x   [verb, noun:held]
            x   "drop"
            x   Perform the verb on the noun.
        x   [verb, noun:usable]
            x   "read"
            x   The noun must be available for use.  As a rule,
                a noun is available for use if it is:
                x   visible
                x   If portable, then held.
            x   E.g., "read note".
x   Ideas:
    x   Maybe add a system that scans the list of things and categorizes them
        between game turns.
        x   Visible, Held, Takeable, Droppable, etc.
        x   Save them in lists owned by the PlayerComponent.
            x   visible, held, takeable, etc.
            x   THIS.  This is very cool, and will simplify the
                command processing a lot.
                x   Puts all of the logic in one place.
            x   Eventually, the same scheme can be used by NPCs.
        x   However, how does this work with special actions, e.g.,
            "wash hands"?
    x   Perhaps better:
        x   Absolutely compute which things are "visible" once.
        x   Then provide predicates for other conditions, e.g.,
            held, gettable, usable, portable, etc.
    x   This all seems to be part of the inventory system.
        x   Or, maybe call it the "stuff" system.
x   Action Items:
    x   Define input parsing and command simplification
        x   Define Command struct; that's where the data goes.
        x   Define synonym mapping
        x   Leave multiple commands/command queue for later.
        x   DONE.

2018-12-23 (Sunday)
x   Text formatting plan
    x   Add conmark module
        x   Reference the textwrap crate.
        x   Add conmark::conwrap(), which uses textwrap to wrap to
            the console line length.
        x   Add conmark::confmt(), which responds to a dirt-simple
            markup.
            x   textwrap honors newlines, which is good.
            x   But the newlines in multi-line strings are usually
                not where we want line-breaks.
            x   conmark::confmt() processes a string like this:
                x   Trims beginning and end.
                x   Replaces newlines with spaces.
                x   Replaces "|" with newline.
                    x   Put newline at the *beginning* of a new line.
            x   Normally, then, a string will be flattened and wrapped,
                but specific strings can choose to have additional
                formatting.
    x   In console::, add output methods that use confmt and conwrap.
        x   And add macros that use format! on their argument, and
            call the confmt/conwrap output methods.
    x   Add visual:: module that uses these.
x   Things done:
    x   Added conmark::
    x   Added console:: methods
    x   Added visual:: system, and revised the app to use it.
    x   Added visual::prose()...para() mechanism for building up and
        outputting strings.

2018-12-22 (Saturday)
x   Lots of stuff to think about.
x   Room/Thing Hybrids
    x   Observations
        x   A vehicle is a thing:
        x It can be described as part of the content of a room.
        x It can be moved from room to room (by driving it).
    x   A vehicle is a room:
        x   The player can be inside it.
        x   It can be described as a location.
        x   It will have its own inventory.
    x   I can implement this a couple of ways
        x   Option A: As a single entity which has the components for a
            Thing and for a Room (and possibly for a Vehicle as well)
        x   Option B: As two entities with a special link between them.
    x   Option A seems simpler.
        x   But then, Rooms and Things need different prose, because
            a Vehicle would need both.
        x   Implies a ThingComponent and a RoomComponent.
            x   Neither would include the Inventory, as
                players, things, rooms, and NPCs can all have inventories.
x   Visual System
    x   In standard ECS, the systems are independent, and the main loop
        fires each in turn.
    x   This is useful; but that's mostly because everything's happening
        at once, e.g., the Visual System needs to render the results of
        the Physical system, etc.
    x   In Bonaventure, the basic time unit is the player turn, and
        visuals are triggered by the player's actions, e.g., you don't
        re-render the room if the player hasn't changed rooms, unless
        the player specifically looks at it.
    x   But that doesn't mean that we can't have a visual system that's
        responsible for displaying information about things, rooms,
        vehicles, etc, from the player's point of view.
    x   Instead of the single "system()" method, it would have a variety
        of methods for different kinds of description, and would be
        responsible for "rendering" a description as formatted text.
x   Scenery vs. Other Things
    x   At present, both scenery and movable things are in the room's
        inventory.
        x   In some ways would be more convenient to have two inventory
            lists one for scenery and one for non-scenery.
        x   But what if we then need three kinds of thing: do we add
            a third list?
    x   I think just like we need a visual system, we need an inventory
        system, for interacting with the things available to the player
        in his current environment.  It would provide methods for
        finding things by name, getting their details, finding lists of
        different kinds of things, and so forth.
x   Architectural Issues
    x   The World struct should provide methods for low-level manipulation
        and simple queries
        x   These form the basic mechanism layer, and will be used by
            the user's actions.  They are useful for updating multiple
            entities at once, when creating multiple views would be
            onerous.
        x   E.g.,
            x   Remove a thing from a location
            x   Put a thing in a location, and update the location's
                inventory
            x   Get a thing's location
            x   Get a view of an entity
            x   Get a view of the player
            x   Link two rooms in a direction.
            x   Bidirectional link two rooms in two directions
            x   Delete the link(s) between two rooms
    x   The code should be divided in two layers: the scenario and the
        engine.
        x   Ideally, any logic written in Rust should be in the engine.
        x   The scenario should be stuff that in principle could be loaded
            from a data file.
        x   That means that any predicates or actions defined by the
            scenario need to be definable as "byte code", not as closures.
        x   Also, the scenario can't add to the set of Flags; which means
            we need some generic Flags for scenario use.
x   Revised the debugging verbs.
    x   All debugging verbs begin with "!".
        x   At present this is done in the normal command parser; the
            verb simple begins with a "!" character.
        x   Might want to use a special parser for debugging commands,
            triggered by an initial "!".
            x   Would allow circumventing any grammar code.
            x   Would be easier to disable all debugging commands.
    x   Debugging commands that take an entity argument now accept
        tags as well as IDs.
    x   Added !examine, !look, and !go.
x   Rooms vs. Things vs. NPCs
    x   A room must have:
        x   A name
        x   A visual string
        x   Links
        x   An inventory
        x   A variable set
    x   A thing must have
        x   A noun, for use in the grammar
        x   A name for display
        x   A visual string
        x   A location
        x   A variable set
        x   Possibly, an inventory
    x   An entity that is both a room and a thing will need:
        x   Only one variable set
        x   Only one inventory.
        x   Only one set of Links
        x   A room name and visual string
        x   A thing name and visual string and noun.
    x   An NPC is a thing with behavior
x   Added PlayerInfo, RoomInfo, ThingInfo components based on the above
    analysis.
    x   The EntityBuilder syntax is now much nicer;
        x   The new player(), room(), and thing() methods unequivocally
            add those components in an unequivocal way.
        x   They also add necessary trimmings, i.e., inventory for both
            room and player.
x   RuleComponent is now RuleInfo.
    x   Added an action() EntityBuilder method.  The once() and always()
        methods add a rule with an empty actions vector; action() requires
        that the entity be a rule, and adds the action to the vector.
x   ProseComponent is now BookInfo.
    x   You can only add a book() to an entity if it's already a thing.
x   Removed obsolete components, e.g., name, loc, visual.
x   Replaced the VarSet type alias with a rule type, FlagSet.
    x   Vars are now Flags, because they really are.
