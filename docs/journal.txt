Bonaventure Journal

2018-12-26 (Wednesday)
x   LOTS of work done so far today.
    x   Completely refactored the entity data structures.
    x   Components are stored in component-specific hash maps; there is
        no longer any Entity struct.
    x   Every component has a *Component struct; these are in
        crate::entity submodules.
    x   It seems to be working, but I need to do lots of testing
        (and add test suites where appropriate).

2018-12-25 (Tuesday)
x   Getting back to basics.
x   "restart" or "undo" commands
    x   To restart the game means creating a new World struct.  But the
        World struct *is* the game struct; there's no way a method can
        mutate the World to create a new World.
        x   Implies that we need a game struct that owns the World, and that
            we pass the Game to the systems.  Then the player_control system
            can define an entirely new World.
        x   We probably also want a "Scene" object or function pointer,
            with which the game is configured, that's used to create the
            new world.
        x   For "restart" we don't need to preserve the player data or
            a state of the World (we can simply recreate the whole thing)
            but for "undo" we would need to.  That means that the World
            needs to support clone().
x   Implemented a Game struct and a "restart" command, but it isn't right yet.
    x   "restart" does indeed recreate the game.
    x   BUT, the player view is saved when the command ends; and it is no
        longer valid.
    x   We end up with the new World, but the old Player.  This is no good.
        x   Which, I suppose, is not surprising; this bug is inherent in the
            view scheme I'm using.
    x   However, I need to handle this.  What are my options?
        x   Option A: reset PlayerView
            x   On restart, set the read-write fields of the PlayerView
                to match the new world.  Then when they get written back,
                there's no problem.
            x   ISSUE: I can't change what the system's player variable
                points to, so I can't restore the PlayerView wholesale.
            x   I'd have to set the particular fields, which is fragile;
                later on I'll add one, and forget to reset it on restart.
                No good.
        x   Option B: Make/save PlayerView explicitly
            x   Each command acquires and saves PlayerView.  This is safer,
                but tedious; and I'm likely to forget a save() at some point.
        x   Option C: Special OK returns
            x   At present, OK returns ().  But I could make it an Enum
                for the different special cases, e.g., Restart, Undo.
    x   Option C appears to work pretty well.
x   Made World cloneable
    x   Just had to derive Clone for World and Entity.
x   Next:
    x   Figure out where Game struct should go.
    x   Undo
x   Undo
    x   At beginning of player_control::system(), clone the world.
    x   On Ok(Normal), push the clone onto the undo stack.
    x   On Ok(Undo), set the world to the state at the top of the stack.
    x   On Ok(Restart), clear the stack.
        x   The actual restart should be done on Ok(Restart), not in the
            cmd_restart routine.  In fact, "restart" => Ok(Restart).
x   Did all that.

2018-12-24 (Monday)
x   Command Processing
    x   Input parsing
        x   Commands beginning with "!" are debugging commands, and
            should be processed separately.
        x   The "." character separates individual commands on the
            command line.
            x   However entered, each command represents a game turn.
            x   Consequently, we need a command queue.
            x   However, some situations should clear the queue.
                x   Command errors.
        x   Other punctuation should be removed, e.g., commas.
        x   Finally, each command is broken on whitespace into a list of
            words.
    x   Command simplification
        x   Once a command has been discovered, it needs to be prepared
            for execution.
        x   Strip articles (a, an, the) as they do not affect the sense.
        x   Replace synonyms with canonical words, e.g., from "n" to
            "north", from "x" to "examine", from "take" to "get".
            x   Simplifies the pattern matcher.
            x   We need a mapping from synonyms to canonical words
            x   Probably necessary only for verbs; nouns and (eventually)
                adjectives are visible in the text, but verbs have to
                be guessed at.
            x   Probably want a "verbs" command to list the canonical
                verbs.
            x   The scenario needs to be able to add synonyms.
        x   Then, normal pattern matching can be used to execute the
            commands.
    x   Sentence forms
        x   Normal pattern matching can take us from command vectors
            to cmd_* functions for execution.  However, by studying
            the command forms, we can conceivably automate much of
            the error handling.
        x   [verb]
            x   E.g., "east", "west", "look", "help", "verbs".
            x   Execute the verb.
        x   [verb, noun:visible]
            x   "examine"
            x   Perform the verb on a thing that's visible in the
                room:
                x   In the player's inventory
                x   In the room's inventory
                x   Ultimately, in any open container in the room.
        x   [verb, noun:cantake]
            x   "get"
            x   Perform the verb on the noun that is visible and can
                be picked up.
            x   E.g., "get note".
        x   [verb, noun:held]
            x   "drop"
            x   Perform the verb on the noun.
        x   [verb, noun:usable]
            x   "read"
            x   The noun must be available for use.  As a rule,
                a noun is available for use if it is:
                x   visible
                x   If portable, then held.
            x   E.g., "read note".
x   Ideas:
    x   Maybe add a system that scans the list of things and categorizes them
        between game turns.
        x   Visible, Held, Takeable, Droppable, etc.
        x   Save them in lists owned by the PlayerComponent.
            x   visible, held, takeable, etc.
            x   THIS.  This is very cool, and will simplify the
                command processing a lot.
                x   Puts all of the logic in one place.
            x   Eventually, the same scheme can be used by NPCs.
        x   However, how does this work with special actions, e.g.,
            "wash hands"?
    x   Perhaps better:
        x   Absolutely compute which things are "visible" once.
        x   Then provide predicates for other conditions, e.g.,
            held, gettable, usable, portable, etc.
    x   This all seems to be part of the inventory system.
        x   Or, maybe call it the "stuff" system.
x   Defined input parsing and command simplification
    x   Defined Command struct; that's where the data goes.
    x   Defined article and punctation stripping.
    x   Defined synonym mapping
    x   Leaving multiple commands/command queue for later.
    x   DONE.
x   Added "readline" support using rustyline.  Very nice.
x   Fancy command patterns (e.g., matching against "noun:held"), etc.,
    should wait until I have the "stuff"/"inventory"/"environment"
    system implemented.
x   "Environment" system:
    x   Queries and summarizes the environment from the standpoint of
        an agent (i.e., the player or an NPC)
        x   What things are visible
        x   Aspects of those things: Held, Usable, Gettable
            x   Need ability to do magic things, i.e.,
                "It slips from your fingers" error when you try to
                pick up something slippery.
    x   Probably want to wait on this until I've got a better idea
        of what will be needed.
x   Gaps: Things text adventures do that I haven't implemented yet.
    x   Monsters
        x   Things that act on their own, and might frustrate you
    x   NPCs
        x   Characters that you can interact with, and might or might
            not act on their own.
        x   Text-oriented dialogs.
            x   Should affect the prompt.
    x   Doors (locked and otherwise)
    x   Containers (locked and otherwise)
    x   Windows
x   Wild ideas: how to make this a real game.
    x   Nobody needs a standard text adventure framework; that (very small)
        niche is covered.  Plus, I'm not a great I/F author.
    x   So what could I do?
    x   More of a combat-oriented, dungeon crawling thing, with puzzles.
        x   i.e., sort of a text-oriented Zelda
    x   Maybe with some character visuals: maps and things.
    x   Amazingly retro, yet not really like anything that's been done.
        x   Except maybe by MUDs
    x   A game with missions
x   So what would I want to see?
    x   Beautiful descriptions
    x   Interesting characters
    x   Worthwhile loot
    x   Replay-ability
        x   Some randomness
        x   Multiple playing styles
    x   Player has equipment
    x   Missions to go on.
    x   Vehicles, and places you can only go in them.
    x   Distinct places to go
        x   The player moves from "world" to "world".
        x   All we need to save is the player.
    x   Monsters to kill, so weapons, etc...but more like Hack than Angband.
    x   Could use termion, quite reasonably.
        x   Displays current status and location
        x   Could have mini-games that use keystrokes for movement,
            i.e., a mixture of rogue-like and text adventure.
        x   Could display maps
    x   Memory of things you've learned.
x   How should it start?
    x   With a tutorial.  You've got some equipment, some monsters,
        goal is to get to safety.
    x   Should help you along in the usual way.
    x   Collect weapons, fight some bad guys.
    x   Hack your way through the jungle.
    x   Use the password from the note once you manage to read it?
x   Mechanism: events
    x   Different actions trigger different events.  I.e., taking the
        note with dirty hands gets it dirty; taking the sword from the
        stone (the emotional support sword) makes the stone suddenly and
        softly vanish away.
    x   Perhaps user actions can "send events", which can trigger rules.
x   Architecture
    x   Game owns player and current scene
    x   Game knows about other worlds
    x   Only one world is active at a time.
    x   The player becomes an entity in the current scene.
        x   Copy in, copy out.
    x   Entities will clearly need to be dynamic.
    x   Hmmm.  Items, weapons, etc., are entities as well.  Need to
        be preserved across worlds (at least the ones carried by the user).
        x   How to manage this?
        x   Could keep persistent entities in a different list.
        x   Could simply copy the player and his belongings into a
            new vector, and use it as the base for the next world.
            x   Probably this.
        x   Use BTreeMap instead of Vec, so that we never need to
            defrag.
        x   Wrap it into an EntityMap, which keeps track of the next
            index.
        x   Alternatively, just use Vec; then on return to the home area
            begin by building a new vec with just the player and his things
            (equipment and inventory).

2018-12-23 (Sunday)
x   Text formatting plan
    x   Add conmark module
        x   Reference the textwrap crate.
        x   Add conmark::conwrap(), which uses textwrap to wrap to
            the console line length.
        x   Add conmark::confmt(), which responds to a dirt-simple
            markup.
            x   textwrap honors newlines, which is good.
            x   But the newlines in multi-line strings are usually
                not where we want line-breaks.
            x   conmark::confmt() processes a string like this:
                x   Trims beginning and end.
                x   Replaces newlines with spaces.
                x   Replaces "|" with newline.
                    x   Put newline at the *beginning* of a new line.
            x   Normally, then, a string will be flattened and wrapped,
                but specific strings can choose to have additional
                formatting.
    x   In console::, add output methods that use confmt and conwrap.
        x   And add macros that use format! on their argument, and
            call the confmt/conwrap output methods.
    x   Add visual:: module that uses these.
x   Things done:
    x   Added conmark::
    x   Added console:: methods
    x   Added visual:: system, and revised the app to use it.
    x   Added visual::prose()...para() mechanism for building up and
        outputting strings.

2018-12-22 (Saturday)
x   Lots of stuff to think about.
x   Room/Thing Hybrids
    x   Observations
        x   A vehicle is a thing:
        x It can be described as part of the content of a room.
        x It can be moved from room to room (by driving it).
    x   A vehicle is a room:
        x   The player can be inside it.
        x   It can be described as a location.
        x   It will have its own inventory.
    x   I can implement this a couple of ways
        x   Option A: As a single entity which has the components for a
            Thing and for a Room (and possibly for a Vehicle as well)
        x   Option B: As two entities with a special link between them.
    x   Option A seems simpler.
        x   But then, Rooms and Things need different prose, because
            a Vehicle would need both.
        x   Implies a ThingComponent and a RoomComponent.
            x   Neither would include the Inventory, as
                players, things, rooms, and NPCs can all have inventories.
x   Visual System
    x   In standard ECS, the systems are independent, and the main loop
        fires each in turn.
    x   This is useful; but that's mostly because everything's happening
        at once, e.g., the Visual System needs to render the results of
        the Physical system, etc.
    x   In Bonaventure, the basic time unit is the player turn, and
        visuals are triggered by the player's actions, e.g., you don't
        re-render the room if the player hasn't changed rooms, unless
        the player specifically looks at it.
    x   But that doesn't mean that we can't have a visual system that's
        responsible for displaying information about things, rooms,
        vehicles, etc, from the player's point of view.
    x   Instead of the single "system()" method, it would have a variety
        of methods for different kinds of description, and would be
        responsible for "rendering" a description as formatted text.
x   Scenery vs. Other Things
    x   At present, both scenery and movable things are in the room's
        inventory.
        x   In some ways would be more convenient to have two inventory
            lists one for scenery and one for non-scenery.
        x   But what if we then need three kinds of thing: do we add
            a third list?
    x   I think just like we need a visual system, we need an inventory
        system, for interacting with the things available to the player
        in his current environment.  It would provide methods for
        finding things by name, getting their details, finding lists of
        different kinds of things, and so forth.
x   Architectural Issues
    x   The World struct should provide methods for low-level manipulation
        and simple queries
        x   These form the basic mechanism layer, and will be used by
            the user's actions.  They are useful for updating multiple
            entities at once, when creating multiple views would be
            onerous.
        x   E.g.,
            x   Remove a thing from a location
            x   Put a thing in a location, and update the location's
                inventory
            x   Get a thing's location
            x   Get a view of an entity
            x   Get a view of the player
            x   Link two rooms in a direction.
            x   Bidirectional link two rooms in two directions
            x   Delete the link(s) between two rooms
    x   The code should be divided in two layers: the scenario and the
        engine.
        x   Ideally, any logic written in Rust should be in the engine.
        x   The scenario should be stuff that in principle could be loaded
            from a data file.
        x   That means that any predicates or actions defined by the
            scenario need to be definable as "byte code", not as closures.
        x   Also, the scenario can't add to the set of Flags; which means
            we need some generic Flags for scenario use.
x   Revised the debugging verbs.
    x   All debugging verbs begin with "!".
        x   At present this is done in the normal command parser; the
            verb simple begins with a "!" character.
        x   Might want to use a special parser for debugging commands,
            triggered by an initial "!".
            x   Would allow circumventing any grammar code.
            x   Would be easier to disable all debugging commands.
    x   Debugging commands that take an entity argument now accept
        tags as well as IDs.
    x   Added !examine, !look, and !go.
x   Rooms vs. Things vs. NPCs
    x   A room must have:
        x   A name
        x   A visual string
        x   Links
        x   An inventory
        x   A variable set
    x   A thing must have
        x   A noun, for use in the grammar
        x   A name for display
        x   A visual string
        x   A location
        x   A variable set
        x   Possibly, an inventory
    x   An entity that is both a room and a thing will need:
        x   Only one variable set
        x   Only one inventory.
        x   Only one set of Links
        x   A room name and visual string
        x   A thing name and visual string and noun.
    x   An NPC is a thing with behavior
x   Added PlayerInfo, RoomInfo, ThingInfo components based on the above
    analysis.
    x   The EntityBuilder syntax is now much nicer;
        x   The new player(), room(), and thing() methods unequivocally
            add those components in an unequivocal way.
        x   They also add necessary trimmings, i.e., inventory for both
            room and player.
x   RuleComponent is now RuleInfo.
    x   Added an action() EntityBuilder method.  The once() and always()
        methods add a rule with an empty actions vector; action() requires
        that the entity be a rule, and adds the action to the vector.
x   ProseComponent is now BookInfo.
    x   You can only add a book() to an entity if it's already a thing.
x   Removed obsolete components, e.g., name, loc, visual.
x   Replaced the VarSet type alias with a rule type, FlagSet.
    x   Vars are now Flags, because they really are.
