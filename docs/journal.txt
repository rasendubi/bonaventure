Bonaventure Journal

2018-12-23 (Sunday)

x   Text formatting
    x   Add conmark module
        x   Reference the textwrap crate.
        x   Add conmark::conwrap(), which uses textwrap to wrap to
            the console line length.
        x   Add conmark::reformat(), which responds to a dirt-simple
            markup.
            x   textwrap honors newlines, which is good.
            x   But the newlines in multi-line strings are usually
                not where we want line-breaks.
            x   conmark::reformat() processes a string like this:
                x   Trims beginning and end.
                x   Replaces newlines with spaces.
                x   Replaces "|" with newline.
                    x   Put newline at the *beginning* of a new line.
            x   Normally, then, a string will be flattened and wrapped,
                but specific strings can choose to have additional
                formatting.
    x   In console::, add output methods that reformat and wrap.
        x   And add macros that use format! on their argument, and
            call the reformat/wrap output methods.

2018-12-22 (Saturday)

x   Lots of stuff to think about.
x   Room/Thing Hybrids
    x   Observations
        x   A vehicle is a thing:
        x It can be described as part of the content of a room.
        x It can be moved from room to room (by driving it).
    x   A vehicle is a room:
        x   The player can be inside it.
        x   It can be described as a location.
        x   It will have its own inventory.
    x   I can implement this a couple of ways
        x   Option A: As a single entity which has the components for a
            Thing and for a Room (and possibly for a Vehicle as well)
        x   Option B: As two entities with a special link between them.
    x   Option A seems simpler.
        x   But then, Rooms and Things need different prose, because
            a Vehicle would need both.
        x   Implies a ThingComponent and a RoomComponent.
            x   Neither would include the Inventory, as
                players, things, rooms, and NPCs can all have inventories.
x   Visual System
    x   In standard ECS, the systems are independent, and the main loop
        fires each in turn.
    x   This is useful; but that's mostly because everything's happening
        at once, e.g., the Visual System needs to render the results of
        the Physical system, etc.
    x   In Bonaventure, the basic time unit is the player turn, and
        visuals are triggered by the player's actions, e.g., you don't
        re-render the room if the player hasn't changed rooms, unless
        the player specifically looks at it.
    x   But that doesn't mean that we can't have a visual system that's
        responsible for displaying information about things, rooms,
        vehicles, etc, from the player's point of view.
    x   Instead of the single "system()" method, it would have a variety
        of methods for different kinds of description, and would be
        responsible for "rendering" a description as formatted text.
x   Scenery vs. Other Things
    x   At present, both scenery and movable things are in the room's
        inventory.
        x   In some ways would be more convenient to have two inventory
            lists one for scenery and one for non-scenery.
        x   But what if we then need three kinds of thing: do we add
            a third list?
    x   I think just like we need a visual system, we need an inventory
        system, for interacting with the things available to the player
        in his current environment.  It would provide methods for
        finding things by name, getting their details, finding lists of
        different kinds of things, and so forth.
x   Architectural Issues
    x   The World struct should provide methods for low-level manipulation
        and simple queries
        x   These form the basic mechanism layer, and will be used by
            the user's actions.  They are useful for updating multiple
            entities at once, when creating multiple views would be
            onerous.
        x   E.g.,
            x   Remove a thing from a location
            x   Put a thing in a location, and update the location's
                inventory
            x   Get a thing's location
            x   Get a view of an entity
            x   Get a view of the player
            x   Link two rooms in a direction.
            x   Bidirectional link two rooms in two directions
            x   Delete the link(s) between two rooms
    x   The code should be divided in two layers: the scenario and the
        engine.
        x   Ideally, any logic written in Rust should be in the engine.
        x   The scenario should be stuff that in principle could be loaded
            from a data file.
        x   That means that any predicates or actions defined by the
            scenario need to be definable as "byte code", not as closures.
        x   Also, the scenario can't add to the set of Flags; which means
            we need some generic Flags for scenario use.
x   Revised the debugging verbs.
    x   All debugging verbs begin with "!".
        x   At present this is done in the normal command parser; the
            verb simple begins with a "!" character.
        x   Might want to use a special parser for debugging commands,
            triggered by an initial "!".
            x   Would allow circumventing any grammar code.
            x   Would be easier to disable all debugging commands.
    x   Debugging commands that take an entity argument now accept
        tags as well as IDs.
    x   Added !examine, !look, and !go.
x   Rooms vs. Things vs. NPCs
    x   A room must have:
        x   A name
        x   A visual string
        x   Links
        x   An inventory
        x   A variable set
    x   A thing must have
        x   A noun, for use in the grammar
        x   A name for display
        x   A visual string
        x   A location
        x   A variable set
        x   Possibly, an inventory
    x   An entity that is both a room and a thing will need:
        x   Only one variable set
        x   Only one inventory.
        x   Only one set of Links
        x   A room name and visual string
        x   A thing name and visual string and noun.
    x   An NPC is a thing with behavior
x   Added PlayerInfo, RoomInfo, ThingInfo components based on the above
    analysis.
    x   The EntityBuilder syntax is now much nicer;
        x   The new player(), room(), and thing() methods unequivocally
            add those components in an unequivocal way.
        x   They also add necessary trimmings, i.e., inventory for both
            room and player.
x   RuleComponent is now RuleInfo.
    x   Added an action() EntityBuilder method.  The once() and always()
        methods add a rule with an empty actions vector; action() requires
        that the entity be a rule, and adds the action to the vector.
x   ProseComponent is now BookInfo.
    x   You can only add a book() to an entity if it's already a thing.
x   Removed obsolete components, e.g., name, loc, visual.
x   Replaced the VarSet type alias with a rule type, FlagSet.
    x   Vars are now Flags, because they really are.
